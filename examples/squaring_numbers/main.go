package main

import (
	"fmt"
	"github.com/tushar2708/conveyor"
	"os"
	"strconv"
)


func main() {

	args := len(os.Args)
	if args <= 1 {
		fmt.Println(`Missing Example Number.
		Usage: go run main.go <example number>`)
		os.Exit(1)
	}

	exampleToRun, cmdErr := strconv.Atoi(os.Args[1])
	if cmdErr != nil {
		fmt.Println(`Invalid Example Number.
		Usage: go run main.go <example (1, 2, or 3)>`)
		os.Exit(1)
	}

	var testConveyor *conveyor.Conveyor
	var cnvErr error

	if exampleToRun == 1 {
		testConveyor, cnvErr = prepareLoopingConveyor()
	} else if exampleToRun == 2 {
		testConveyor, cnvErr = prepareTransactionalConveyor()
	} else if exampleToRun == 3 {
		testConveyor, cnvErr = prepareComplexTransactionalConveyor()
	} else {
		fmt.Println(`Example number is invalid.
		Usage: go run main.go <example number (1, 2, or 3)>
		1: Simple conveyor with loop mode
		2: Simple conveyor with transaction mode
		3: A conveyor with multiple operation and sink nodes`)
		os.Exit(1)
	}

	if cnvErr != nil {
		fmt.Printf("conveyor preparation failed for example: %d. cnvErr:[%v]\n", exampleToRun, cnvErr)
		os.Exit(1)
	}

	if err := testConveyor.Start(); err != nil {
		fmt.Printf("conveyor start failed for example: %d. cnvErr:[%v]\n", exampleToRun, cnvErr)
	}

	fmt.Println("All Done")

}


// NumberSource generates a sequence of numbers (0...count) when it is run with conveyor
type NumberSource struct {
	*conveyor.ConcreteNodeExecutor
	count int
}

// SquareOperator squares the numbers generated by NumberSource, when it is run with conveyor
type SquareOperator struct {
	*conveyor.ConcreteNodeExecutor
}

// AdditionOperator adds a configurable number to square generated by NumberSource, when it is run with conveyor
type AdditionOperator struct {
	*conveyor.ConcreteNodeExecutor
	toAdd int
}

// PrinterSink prints the final numbers calculated by Operators, when it is run with conveyor
type PrinterSink struct {
	*conveyor.ConcreteNodeExecutor
}

// PrinterSink1 composes "PrinterSink", and has slightly different Execute() method
type PrinterSink1 struct {
	*PrinterSink
}

// PrinterSink2 composes "PrinterSink", and has slightly different Execute() method
type PrinterSink2 struct {
	*PrinterSink
}

// PrinterSink3 composes "PrinterSink", and has slightly different Execute() method
type PrinterSink3 struct {
	*PrinterSink
}

// ReplicateJoint is a joint executor, which acts as an intermediate node,
// that doesn't change the incoming data, but just replicates it, to multiple nodes
// You can write your own versions of "conveyor.ConcreteJointExecutor", which may:
// 1. Distribute data from one node equally to a set of different nodes.
// 2. Distribute data from one node in fractions.
// 3. Distribute data based on some condition.
// 4. Anything else that you can think of
type ReplicateJoint struct {
	*conveyor.ConcreteJointExecutor
	OutChanCount int
}

/*
	function Count() decides how many goroutines will be running for the source node.
	You must ensure that if it returns a number greater than 1,
	then "Execute" & "ExecuteLoop" methods must be race-free,
	either by using locks or by isolating resources to be run independently
 */

// Count of go-routines for source node
// (kept as one, as "addition" done in Execute* methods isn't race-free)
func (src *NumberSource) Count() int {
	return 1
}

// Count of go-routines for operation node
// (3 go-routines allowed, as Execute* methods don't depend on any common resource)
func (oper *SquareOperator) Count() int {
	return 3
}

// Count of go-routines for sink node
// (5 go-routines allowed, as Execute* methods don't depend on any common resource)
func (snk *PrinterSink) Count() int {
	return 5
}

/*
	Some more nodes, for getting into further details
 */

// ExecuteLoop (source) gets called by the conveyor, if the Executor is added with "WorkerModeLoop".
// In this method, you ignore "inChan" because source is supposed to generate new data
// and you should write your newly generated data to "outChan"
func (src *NumberSource) ExecuteLoop(ctx conveyor.CnvContext, inChan <-chan map[string]interface{}, outChan chan<- map[string]interface{}) error {

	// Below is just a sample code, as an actual use case you can do anything,
	// that starts streaming data to your pipeline
	// It could either be reading from a database, a file, a kafka stream, etc
	for i := 0; i <= src.count; i++ {
		outChan <- map[string]interface{}{"num": i}
	}
	return nil
}

// ExecuteLoop (operator) gets called by the conveyor, if the Executor is added with "WorkerModeLoop".
// In this method, you should read from "inChan" and write to "outChan"
func (oper *SquareOperator) ExecuteLoop(ctx conveyor.CnvContext, inChan <-chan map[string]interface{}, outChan chan<- map[string]interface{}) error {

	// Below is just a sample code, as an actual use case you can make an API call here,
	// based on data received from source node, and pass on the enriched data to the next node in conveyor
	for m := range inChan {
		num := m["num"].(int)
		sqr := num * num
		m["sqr"] = sqr
		outChan <- m
	}
	return nil
}

// ExecuteLoop (sink) gets called by the conveyor, if the Executor is added with "WorkerModeLoop".
// In this method, you should read from "inChan" and write to "outChan"
func (snk *PrinterSink) ExecuteLoop(ctx conveyor.CnvContext, inChan <-chan map[string]interface{}, outChan chan<- map[string]interface{}) error {

	// Below is just a sample code, as an actual use case you can do anything that terminates your pipeline,
	// It could either be sending data to the last API service, storing data to a database, or publishing it to kafka
	for m := range inChan {
		fmt.Printf("Output data:[+%v]\n", m)
	}
	return nil
}

// Execute (source) gets called by the conveyor, if the Executor is added with "WorkerModeTransaction".
// In this method, you ignore "inData" because source is supposed to generate new data
// and you should return your generated data as "outData"
func (src *NumberSource) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	if src.count < 0 {
		return nil, conveyor.ErrSourceExhausted
	}
	outData := map[string]interface{}{"num": src.count}
	src.count -= 1

	return outData, nil
}

// Execute (square operator) gets called by the conveyor, if the Executor is added with "WorkerModeTransaction".
// In this method, you get "inData" as input, and you should return it's modified form as output
func (oper *SquareOperator) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	num := inData["num"].(int)
	sqr := num * num
	inData["sqr"] = sqr

	return inData, nil
}

// Execute (addition operator) gets called by the conveyor, if the Executor is added with "WorkerModeTransaction".
// In this method, you get "inData" as input, and you should return it's modified form as output
func (addr *AdditionOperator) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	sqr := inData["sqr"].(int)
	added := sqr + addr.toAdd
	inData["added"] = added

	return inData, nil
}

// Execute (sink) gets called by the conveyor, if the Executor is added with "WorkerModeTransaction".
// In this method, you get "inData" as input, which you should take some action on (eg. printing in this case)
// Anything you return as "outData" will be ignored, because this is supposed to be the terminating node of the conveyor
func (snk *PrinterSink) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	fmt.Printf("Output data:[+%v]\n", inData)
	return inData, nil
}

func (snk *PrinterSink1) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	fmt.Printf("PrinterSink1 says ---> Output data:[+%v]\n", inData)
	return inData, nil
}
func (snk *PrinterSink2) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	fmt.Printf("PrinterSink2 says ------> Output data:[+%v]\n", inData)
	return inData, nil
}
func (snk *PrinterSink3) Execute(ctx conveyor.CnvContext, inData map[string]interface{}) (map[string]interface{}, error) {

	fmt.Printf("PrinterSink3 says ---------> Output data:[+%v]\n", inData)

	return inData, nil
}

func prepareLoopingConveyor() (*conveyor.Conveyor, error) {
	cnv, err := conveyor.NewConveyor("square_printer", 10)
	if err != nil {
		return nil, err
	}

	// Create a source executor, and add it to conveyor.
	// A pipeline may have only one source node
	gen := &NumberSource{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_generator",
		},
		count: 20,
	}
	if err := cnv.AddNodeExecutor(gen, conveyor.WorkerModeLoop, conveyor.WorkerTypeSource); err != nil {
		fmt.Printf("Failed to add NumberSource to conveyor :[+%v]", err)
	}

	// Create an operation executor, and add it to conveyor.
	// A pipeline may have many operation nodes
	sqr := &SquareOperator{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_squarer",
		},
	}
	if err := cnv.AddNodeExecutor(sqr, conveyor.WorkerModeLoop, conveyor.WorkerTypeOperation); err != nil {
		fmt.Printf("Failed to add SquareOperator to conveyor :[+%v]", err)
	}

	// Create a sink executor, and add it to conveyor.
	// A pipeline may have only multiple sink nodes, however this example shows only one.
	// Look for the 3rd example to see how you can stream same data to multiple sinks using a joint
	prnt := &PrinterSink{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_printer",
		},
	}
	if err := cnv.AddNodeExecutor(prnt, conveyor.WorkerModeLoop, conveyor.WorkerTypeSink); err != nil {
		fmt.Printf("Failed to add PrinterSink1 to conveyor :[+%v]", err)
	}

	return cnv, nil
}

func prepareTransactionalConveyor() (*conveyor.Conveyor, error) {
	cnv, err := conveyor.NewConveyor("square_printer", 10)
	if err != nil {
		return nil, err
	}

	gen := &NumberSource{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_generator",},
		count: 20,
	}

	if err := cnv.AddNodeExecutor(gen, conveyor.WorkerModeLoop, conveyor.WorkerTypeSource); err != nil {
		fmt.Printf("Failed to add NumberSource to conveyor :[+%v]", err)
	}

	sqr := &SquareOperator{ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_squarer",},}

	if err := cnv.AddNodeExecutor(sqr, conveyor.WorkerModeLoop, conveyor.WorkerTypeOperation); err != nil {
		fmt.Printf("Failed to add SquareOperator to conveyor :[+%v]", err)
	}



	prnt := &PrinterSink{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_printer",
		},
	}

	if err := cnv.AddNodeExecutor(prnt, conveyor.WorkerModeLoop, conveyor.WorkerTypeSink); err != nil {
		fmt.Printf("Failed to add PrinterSink1 to conveyor :[+%v]", err)
	}

	return cnv, nil
}

func prepareComplexTransactionalConveyor() (*conveyor.Conveyor, error) {
	cnv, err := conveyor.NewConveyor("square_printer", 10)
	if err != nil {
		return nil, err
	}

	gen := &NumberSource{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_generator",
		},
		count: 20,
	}

	if err := cnv.AddNodeExecutor(gen, conveyor.WorkerModeLoop, conveyor.WorkerTypeSource); err != nil {
		fmt.Printf("Failed to add NumberSource to conveyor :[+%v]", err)
		return nil, err
	}

	sqr := &SquareOperator{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{
			Name: "number_squarer",
		},
	}

	if err := cnv.AddNodeExecutor(sqr, conveyor.WorkerModeTransaction, conveyor.WorkerTypeOperation); err != nil {
		fmt.Printf("Failed to add SquareOperator to conveyor :[+%v]", err)
		return nil, err
	}

	addr := &AdditionOperator{
		ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_adder",},
		toAdd: 5,
	}

	if err := cnv.AddNodeExecutor(addr, conveyor.WorkerModeTransaction, conveyor.WorkerTypeOperation); err != nil {
		fmt.Printf("Failed to add AdditionOperator to conveyor :[+%v]", err)
	}

	/*
	Create a replication joint, and add it to conveyor using "AddJointExecutorAfterNode" method
	  */
	joint, jntErr := conveyor.NewReplicateJoint("replicator", 3)
	if jntErr != nil {
		fmt.Printf("Failed to add SquareOperator to conveyor :[+%v]", err)
		return nil, jntErr
	}

	if err := cnv.AddJointExecutorAfterNode(joint, conveyor.WorkerModeLoop, conveyor.WorkerTypeJoint); err != nil {
		return nil, err
	}

	/*
	Create 3 sink nodes, and add it to conveyor using "AddNodeExecutorAfterJoint" method.
	Make sure that you are adding this method, and not "AddNodeExecutor"
	whenever you need to connect a "Node" next to a "Joint"
	  */

	prnt1 := &PrinterSink1{
		PrinterSink: &PrinterSink{ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_printer"}},
	}
	if err := cnv.AddNodeExecutorAfterJoint(prnt1, conveyor.WorkerModeTransaction, conveyor.WorkerTypeSink); err != nil {
		fmt.Printf("Failed to add PrinterSink1 to conveyor :[+%v]", err)
	}

	prnt2 := &PrinterSink2{
		PrinterSink: &PrinterSink{ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_printer"}},
	}
	if err := cnv.AddNodeExecutorAfterJoint(prnt2, conveyor.WorkerModeTransaction, conveyor.WorkerTypeSink); err != nil {
		fmt.Printf("Failed to add PrinterSink2 to conveyor :[+%v]", err)
	}

	prnt3 := &PrinterSink3{
		PrinterSink: &PrinterSink{ConcreteNodeExecutor: &conveyor.ConcreteNodeExecutor{Name: "number_printer"}},
	}
	if err := cnv.AddNodeExecutorAfterJoint(prnt3, conveyor.WorkerModeTransaction, conveyor.WorkerTypeSink); err != nil {
		fmt.Printf("Failed to add PrinterSink3 to conveyor :[+%v]", err)
	}

	return cnv, nil
}
